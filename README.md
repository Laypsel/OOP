# Проект розробки інтернет магазину, у якому продаються ігри на будь-які платформи і самі платформи.
# Функціональні вимоги
 <b>Реєістрація користувача</b>
  <p>1) Користувач може реєструватися у додатку, вказавши особисті дані: ім'я, прізвище, електронну адресу, номер телефону тощо.</p>
       1.1) Як гість - може переглядати усі товари, але без реєстрації купити не зможе. 
       1.2) Зареєстрований користувач - може купувати товари, редагувати профіль, свої замовлення а також отримує рекламу і додаткові новини.
  3) Адміністратор може реєструватися у магазині, вказавши особисті дані: ім'я, прізвище, електронну адресу, номер телефону тощо.
  4) Система повинна перевіряти унікальність електронної адреси та номера телефону користувача під час реєстрації.

<b>Пошук і фільтрація</b>
  1) Пошук ігор за назвою, жанром, платформою тощо.
  2) Фільтрація ігор за різними параметрами, такими як жанр, вікові обмеження, рейтинг тощо.

<b>Перегляд інформації про гру</b>
  1) Відображення детальної інформації про гру (назва, опис, жанр, рейтинг, вікові обмеження, ціна тощо).
  2) Можливість перегляду відеооглядів та зображень гри.
  3) Відгуки користувачів та оцінки гри.

<b>Додавання товарів до кошика</b>
  1) Можливість додавання ігор до кошика для подальшої покупки.
  2) Обмеження на певну кількість товару у кошик.
  3) Повернення товару з кошику назад у магазин, якщо він знаходиться у кошику більше ніж три дні.

<b>Оформлення замовлення</b>
  1) Введення адреси доставки і обрання методу оплати.
  2) Підтвердження замовлення перед його остаточним оформленням.

<b>Оплата і доставка</b>
  1) Можливість оплати замовлення онлайн різними способами (кредитна картка, PayPal, платіжні системи тощо).
  2) Вибір способу доставки (електронна доставка, доставка на диск або фізичний носій тощо).

<b>Особистий кабінет користувача</b>
  1) Можливість перегляду історії замовлень.
  2) Зміна особистих даних (адреса, пароль тощо).

<b>Адміністративна панель</b>
  1) Можливість додавання, редагування та видалення товарів.
  2) Управління замовленнями користувачів.
  3) Моніторинг статистики продажів та інших аналітичних даних.

<b>Взаємодія з користувачами</b>
  1) Система підтримки для запитань та проблем користувачів.
  2) Формування розсилок з акціями та новинами про нові гри.

<b>Поповнення товару у магазин</b>
  1) Відбувається синхронізація зі складом, де знаходиться товар.
  2) Надається інформація скільки певного товару зараз є.
  3) Якщо товар закінчився, пишеться що товар закінчився.

<hr>
<hr>


# Лабораторні роботи
# ЛР1

Третій рівень.

<p><b>Фабричний метод (Factory Method)</b></p>
<p>Так як суть даного патерна полягає в створені інтерфейсу для створення однорідних обєктів з можливістюю зміни типів цих обєктів, реалізацію даної фабрики можна продемонструвати на прикладі регістрації у магазині.</p>
<p>У коді code1 створенно абстрактиний метод UserFactory для створення корисувачів, які зареєструвалися до магазину щоб потім виконувати замовлення та інші функції у магазині, які не дозволені не зареєстрованим користувачам Guest.</p>

<p><b>Абстрактна фабрика (Abstract Factory)</b></p>

<p>Абстрактна фабрика — це породжувальний патерн проектування, що дає змогу створювати сімейства пов’язаних об’єктів, не прив’язуючись до конкретних класів створюваних об’єктів.</p>
<p>Цей патерн було реалізовано у code2, у якому було створено інтерфейс IUserFactory - для створення юзера загально. А потім підʼєднано інші фабрики, для створення певного типу користувача. З них є GuestFactory - де звичайні не зареʼєстровані користувачі заходять до магазину; RegisteredUserFactory - зареʼєстровані користувачі, які матимуть прово на покупку, замовлення, відгуки; AdminFactory - адміністратори, які керують магазином а також користувачами.</p>
<p>Тепер ми маємо три типи людей які заходитимуть до магазину, при цьому кожен буде з дозволеними функціями в залежності до типу. При цьому код не потрібно оновлювати, оскільки він буде підключений до бази користувачів які реєструвалися до магазину і уся інформація збережеться там.</p>

<hr>
<hr>

# ЛР2

<p>Третій рівень.</p>
<p><b>Прототип (Prototype). Будівельник (Builder).</b></p>
 <p>У рамках вирішення задачі про знаходження та фільтрації ігор потрібно реалізувати класи які для самостійного пошуку та керування іграми згідно певних ключових слів які додаються у пошуку, або певної категорії у фільтрі. Для цього потрібно застосувати два патерни Прототип та Будівельник.</p>

 <p>Будівельник для створення коласу Game, який буде представляти гру має мплементувати інтерфейс IGameBuilder для того щоб побудувати ігру згідно методів BuildTitle, BuildGenre, BuildPlatform, BuildAgeRating, і у кінці отримати GetGame.</p>

 <p>Реалізація прототипу має GamePrototype має імплементувати інтерфейс GamePrototype що буде вимагати реалізацію метода clone (). Цей метод використовується для того щоб створити обʼєкти на основі існуючого обʼєкту Game.</p>

<hr>
<hr>

# ЛР3

<p>Третій рівень.</p>
<p><b>Стратегія (Strategy)</b></p>

<p>У цьому коді (code1.cs) ми використовуємо паттерн Стратегії для визначення різних методів додавання товарів до кошика. Для цього треба створити інтерфейс (клас IAddToCartStrategy)</p>
<p>Контекст ShoppingCart може приймати різні стратегії додавання товару, такі як звичайне додавання або додавання зі знижкою. Клас Product використовується для представлення товарів у магазині.</p>

<p><b>Спостерігач (Observer)</b></p>

<p>Для виконання задачі, в ході якої потрібно реалізувати клас (Admin) у коді (code2.cs), за допомогою якого адміністратор зможе спостерігати за замовленнями їхніми статусами, а також за профілями клієнтів. Клас OrderManager виступає в ролі спостеріганого об'єкта, який може сповіщати своїх спостерігачів про зміни в статусі замовлень.</p>

<p><b>Команда (Command)</b></p>

<p>Для виконання задачі реалізації пункту оформлення замовлення було використано патерн Команда у коді (code3.cs). Класи PlaceOrderCommand та CancelOrderCommand представляють конкретні команди для оформлення та скасування замовлення відповідно. Клас OrderReceiver є отримувачем команд, який виконує фактичну роботу. Клас OrderInvoker є інвокером команд, який виконує команди.</p>

<hr>
<hr>

# ЛР4

<p>Третій рівень.</p>

<p><b>Макрокоманди</b></p>

<p>У ході цього завдання де відбувається реалізація перегляду інформації про товар (гру), у якому буде включено декілька окремих кроків для перегляду інформації</p>

<p>У коді (code1.cs) використовуючи патерн Макрокоманди для створення комплексної команди MacroCommand, яка включає в себе декілька окремих команд для перегляду різних аспектів інформації про гру. Кожна окрема команда ViewGameInfoCommand виконує перегляд конкретної частини інформації про гру. При виклику методу Execute() макрокоманди, всі включені команди виконуються послідовно, що дозволяє зручно переглядати весь обсяг інформації про гру в одному виклику.</p>

<p><b>Шаблонний метод (Template Method)</b></p>

<p>Використати патерн "Шаблонний метод" у коді (code2.cs),  щоб визначити загальну структуру створення оплати та доставки у базовому класі (OrderProcessTemplate), який містить алгоритм оплати і доставки в методі ProcessOrder. Кожен конкретний крок цього алгоритму реалізований у відповідному захищеному віртуальному методі. Класи OnlineOrderProcess та CashOnDeliveryProcess наслідують від базового класу і реалізують ці методи відповідно до специфіки онлайн-оплати та оплати при отриманні. Кожен із цих класів може бути використаний для обробки замовлення згідно з його специфікацією.</p>

<hr>
<hr>

# ЛР5

<p>Третій рівень.</p>

<p><b>Ітератор (Iterator)</b></p>

<p>У рамках реалізаціїї підпункту фільтрації ігор за такими параметрами як жанр, платформа, вікові обмеження, франшизами та рейтингами було використано патерн Ітератор у коді (code1.cs). Для цього було створено ітератор GameIterator який допомагає у фільтрації ігор, згідно параметрами на кожен з яких стоворено певний клас, які підєднані до одного інтерфейсу IFilter.</p>

<p><b>Стан (State)</b></p>

<p>Використати патерн Стан для реалізації стану можливості редагування, додавання та видалення товарів у коді (code2.cs). IProductState - інтерфейс стану товарів. Створенно класи для кожного зі станів та також клас ProductCatalog визначає стан для товару та делегує виконання дій до відповідного об'єкта стану.</p>

<p><b>Ланцюжок Обов'язків (Chain of responsibility)</b></p>

<p>Для виконання задачі реалізації управління замовленнями користувачів у коді (code3.cs). Є абстрактний обробник OrderHandler який замінює інтерфейс, до нього підʼєднано декілька конкретних обробників які відповідають за певну функції у управлінні замовленням. Кожен обробник визначає свої власні правила для обробки замовлення і, якщо потрібно, передає управління наступному обробнику в ланцюжку.</p>

<hr>
<hr>

# ЛР6

<p>Третій рівень.</p>

<p><b>Інтерпретатор (Interpreter)</b></p>

<p>Патерн Інтерпретатор (Interpreter) визначає уявлення граматики для заданої мови і інтерпретатор пропозицій цієї мови. Як правило, даний шаблон проектування застосовується для часто повторюваних операцій. У цьому коді  (code1.cs) паттерн Інтерпретатора використовується для перегляду історії замовлень. Інтерпретатор (OrderHistoryInterpreter) визначає спосіб виведення інформації про замовлення, а клас OrderHistory містить історію замовлень та викликає метод ViewOrderHistory, передаючи йому відповідний інтерпретатор. Цей підхід дозволяє легко змінювати спосіб виведення інформації про замовлення, не змінюючи структуру самого класу OrderHistory.</p>

<p><b>Посередник (Mediator)</b></p>

<p>Патерн Посередник (Mediator) представляє такий шаблон проектування, який забезпечує взаємодію безлічі об'єктів без необхідності посилатися один на одного. Тим самим досягається слабо зв'язність  взаємодіючих об'єктів. У цьому коді (code2.cs) паттерн Посередник використовується для зміни особистих даних користувача. Клас User має методи ChangeAddress та ChangePassword, які змінюють відповідно адресу та пароль користувача і повідомляють посередника про зміни. Посередник, у свою чергу, обробляє повідомлення від користувача і виводить відповідні повідомлення. Такий підхід дозволяє розділити логіку зміни даних та їх обробку.</p>

<hr>
<hr>

# ЛР7

<p>Третій рівень.</p>

<p><b>Зберігач (Memento)</b></p>

<p>Паттерн "Зберігач" (Memento) використовується для збереження стану об'єкту так, щоб він можна було відновити пізніше без розкриття свого внутрішнього представлення. У моєму проекті цей паттерн показано у коді (code1.cs) він використовується для збереження історії запитань та проблем користувачів у системі підтримки.  Клас Issue представляє запитання або проблему, яка має методи Save та Restore для збереження та відновлення свого стану. Клас IssueHistory використовує стек для зберігання зберігачів стану, а метод Undo дозволяє відновити попередній стан. Такий підхід дозволяє користувачам системи підтримки відновлювати попередні стани своїх запитань або проблем.</p>

<p><b>Відвідувач (Visitor)</b></p>

<p>Паттерн "Відвідувач" (Visitor) у коді (code2.cs) дозволяє додавати нові операції до класів без зміни їх структури. У випадку з формуванням розсилок з акціями та новинами про нові ігри, ми можемо використовувати паттерн "Відвідувач" для реалізації різних типів повідомлень в рамках однієї системи. Інтерфейс IVisitable: Оголошує метод Accept, який приймає відвідувача. Конкретні класи Game та Promotion: Реалізують метод Accept, який викликає відповідний метод відвідувача. Інтерфейс IVisitor: Оголошує методи Visit, які визначають операції для кожного типу елемента (гри та акції). Клас NewsletterVisitor: Реалізує інтерфейс IVisitor, надаючи конкретні реалізації для формування повідомлень про нові ігри та акції. Клас Newsletter: Містить список елементів IVisitable і методи для додавання елементів та генерації розсилки за допомогою відвідувача. Клас Program: Створює об'єкти гри та акції, додає їх до розсилки, створює відвідувача і генерує розсилку.
Цей підхід дозволяє легко додавати нові операції або змінювати існуючі без модифікації класів гри та акції, забезпечуючи гнучкість та підтримуваність коду.</p>

<hr>
<hr>

# ЛР8

<p>Третій рівень.</p>

<p><b>Фасад (Facade)</b></p>

<p>Паттерн "Фасад" (Facade) у коді (code1.cs) надає єдиний інтерфейс до групи інтерфейсів у підсистемі, що спрощує взаємодію з нею. У нашому випадку ми можемо використовувати паттерн "Фасад" для синхронізації зі складом, де знаходиться товар.
Підсистема 1: InventorySystem (Управління запасами): UpdateInventory - оновлює кількість продуктів на складі, CheckInventory - перевіряє кількість продуктів на складі.
Підсистема 2: OrderSystem (Управління замовленнями): CreateOrder - створює нове замовлення, CancelOrder - скасовує замовлення.
Підсистема 3: ShippingSystem (Управління доставкою): ShipProduct - відправляє продукт.

Клас WarehouseFacade (Фасад для синхронізації зі складом): Інкапсулює взаємодію з трьома підсистемами (InventorySystem, OrderSystem, ShippingSystem).
Метод SyncProduct перевіряє наявність продукту на складі, створює замовлення, оновлює кількість продукту на складі та організовує відправку.
Клас Program: Створює об'єкт фасаду WarehouseFacade та викликає метод SyncProduct для синхронізації продукту.
Цей паттерн спрощує взаємодію з підсистемами управління складом, замовленнями та доставкою, надаючи єдиний інтерфейс для користувачів системи. Це дозволяє уникнути складнощів при роботі з окремими підсистемами та зменшує зв'язок між компонентами системи.
</p>

<p><b>Замісник (Проксі)</b></p>

<p>Паттерн "Замісник" (Proxy) у коді (code2.cs) забезпечує сурогат або замісник іншого об'єкта для контролю доступу до нього. У нашому випадку ми можемо використовувати паттерн "Замісник" для отримання інформації про те, скільки певного товару є на складі, з можливістю кешування або контролю доступу. Інтерфейс IInventory: Оголошує метод GetStock, який повертає кількість певного товару на складі.
Клас RealInventory: Реалізує метод GetStock, який звертається до реального складу і повертає кількість товару; Використовує словник productStock для зберігання інформації про запаси товару.
Клас InventoryProxy: Реалізує інтерфейс IInventory і виступає в ролі замісника для RealInventory; Використовує кеш для зберігання запитів про запаси товару, щоб зменшити кількість звернень до реального складу; Якщо інформація про запаси товару є в кеші, вона повертається з кешу. Якщо ні, здійснюється звернення до RealInventory, і результат зберігається в кеші.
Клас Program: Створює об'єкт InventoryProxy; Отримує і виводить інформацію про запаси товару, показуючи, як працює кешування.
Цей підхід дозволяє зменшити навантаження на реальний склад за допомогою кешування результатів запитів і забезпечує контрольований доступ до даних про запаси товару.
</p>

<p><b>Міст (Bridge)</b></p>

<p>Паттерн "Міст" (Bridge) у коді (code3.cs) розділяє абстракцію і реалізацію, дозволяючи їм змінюватися незалежно. У випадку з перевіркою наявності товару на складі, ми можемо використовувати "Міст" для розділення логіки перевірки та відображення результатів. Інтерфейс IInventoryImplementation: Оголошує метод GetStock, який повертає кількість певного товару на складі.
Клас RealInventoryImplementation: Реалізує інтерфейс IInventoryImplementation і представляє реальний склад; Метод GetStock звертається до реального складу і повертає кількість товару; Використовує словник productStock для зберігання інформації про запаси товару.
Абстрактний клас Inventory: Містить захищене поле implementation, яке зберігає конкретну реалізацію інтерфейсу IInventoryImplementation; Оголошує абстрактний метод CheckStock, який буде реалізовано в підкласах.
Клас InventoryChecker: Наслідує клас Inventory і реалізує метод CheckStock; Викликає метод GetStock реалізації і перевіряє кількість товару. Якщо товару немає, виводить повідомлення про те, що товар закінчився.
Клас Program: Створює об'єкт RealInventoryImplementation і передає його в InventoryChecker; Викликає метод CheckStock для перевірки наявності різних товарів.
Цей підхід дозволяє легко змінювати реалізації перевірки наявності товару незалежно від логіки відображення результатів, забезпечуючи гнучкість і розширюваність системи.</p>
